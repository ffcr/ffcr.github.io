<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>于此</title>
</head>

<style>
    div{white-space: pre-wrap;}
</style>
<body>
<h1>研发新的人工智能算法</h1>

<h2>个人项目</h2>
<h3>世界运行（人工生命系统模拟）</h3>
<div>
    0.1级别：运行
    <b>世界</b>是<b>运行</b>的。各种物质都按照程序自发运行。只要规则恰当（如b3s23），就会涌现出有意义的图案。
    达到0.1级别的实现：
    <a href="0.1">世界运行0.1</a>，实现于2021年5月。
    效果：可观察到复杂系统的涌现现象。
</div>

<br>
<div>
    0.2级别：进化
    生命程序的基因从固定到可变。这意味着生命<b>程序</b>可以<b>进化</b>。
    达到0.2级别的实现：
    <a href="0.2">世界运行0.2</a>，实现于2021年10月。
    <a href="0.2.1">世界运行0.2.1</a>，实现于2025年4月。
    效果：可以产生更有意思的涌现现象（演化中出现了多种生命模式）。
</div>
<br>


<details>
<summary>四年做不出0.3</summary>
<div style="color: #006600;">
    我很希望我的每一个新版本，都能给我自己带来惊喜。我真的很不想水版本。
    做出0.1的惊喜在于自己第一次动手实现了可随时修改源代码的运行的世界。
    做出0.2的惊喜在于自己第一次动手实现了可随时修改源代码来影响生命进化进程的世界。
    由于我搜索“进化的进化”了解到了自构进化，我原定0.3目标就是实现自构进化。

    然而，实现0.2后，那段时间我发现了很多别人的人工生命项目，例如：
    <a href="https://alien-project.org/">Artificial Life Environment</a>，（靠<a href="https://alien-project.gitbook.io/docs/dive-a-little-deeper/cell-programming/self-replicating-machines">特别设计的GPU汇编语言</a>实现自构，同时靠GPU实现了单机百万生命的壮观景象）
    <a href="https://faculty.hampshire.edu/lspector/gecco2003-collective.html">SwarmEvolve</a>，（靠<a href="https://faculty.hampshire.edu/lspector/push.html">Push语言</a>实现自构）
    <a href="https://github.com/PaulTOliver/salis-v2">Salis</a>（靠类似Tierra的一维内存自修改代码实现自构）
    <a href="https://github.com/Reconcyl/myco">Myco</a>（靠类似Tierra的二维内存自修改代码实现自构）
    虽然发现了很多有意思的内容，但总体景象都大差不差：生命模式总是像一群微生物一样简单，偶尔随便进化几个基因。
    哪怕GPU千倍算力于CPU，达到百万生命了，也不足以自发进化出复杂的模式。因为一滴水的生命就远超这个数目，地球那么大都得进化几十亿年。

    0.2后，我直接就把0.3的目标定为“有学习能力的智能”，不管这个目标有多难，我都想在0.3一步登天。后来我才明白，“智能”这个目标是1.0级的。
    “人类科技发展越来越快，现实的生命也是自我进化，越到后期进化速度越快，通用AI出来后技术将直接爆炸”是对的，<b>但是</b>，前面这几十亿年的<b>前期</b>无论如何都是省略不掉的。

    哪怕明知算法优化到极致后个人电脑算力都能运行通用AI，哪怕通用AI每秒都能自我改进1%，但目前就是处于通用AI出现之前的阶段，电脑程序没法自我进化就是没法自我进化。
    哪怕明知通用学习能力的核心算法肯定能在10000字节内表示，哪怕自构能实现极强的自由度，哪怕知道肯定存在进化算法能做到每秒优化1个bit，几小时就能做出AGI。可是就是没人发现这个算法。

    3年了，我一直在想有什么取巧的方法，或者在1.0之前应该分为哪些阶段。于是便一直研究理论方面，研究了很久很久，3年了，理论还是没有找到。
    0.3的目标换了很多个了：“自我进化程序”、“找出能出现智能的模式”、“每秒能优化1个bit而不会陷入局部最优点的进化算法”、“让生命往最关乎智能和学习能力的方向进化”，总觉得每个都存在不需要以有AGI为前提的解决方法，但总是发现不了。最终把这些词都定性为“智能”的<b>等价</b>表达。天天换说法，就是不解决根本问题。

    为什么一直没进展呢？因为完美主义害人。因为“版本号不能水”，就不能随便写项目。“0.1世界运行，0.2生命进化”，按这个趋势0.3就应该是“智能爆炸”了。问题是这属于科技最前沿，那篇AGI的几万字的论文还没写出来，写AGI代码，每想写出一个正确的字符都举步维艰。

    （2025年1月）
    3年了，读个大学，大一做出的0.2，到大四快毕业了，0.3还迟迟做不出来，像话吗？
    0.2到0.3这版本跨度无论如何都不应该这么久。哪怕从0.1的不进化到0.2的进化属于质的飞跃，也只花了很短时间。如果非要把0.3定义为“出现智能”这个级别的目标，版本永远没法迭代。
    无法迭代版本，便没有目标，没有目标便没有写项目的动力。所以中间这3年我没有写出有质的飞跃的项目，哪怕是“小型”的质的飞跃。

    最终，我把毕业论文和0.3挂钩了，这次无论如何我都要写出一个东西来。
    0.3的目标就定为“自构进化”吧，反正随便写写都能实现自复制机器，就算随便从我的理论研究中拿出五六个自创点子都能造出个有意思的东西，保证能毕业。

    （2025年8月）
    但最终，毕业设计的结果只能算是0.2.1，因为和0.2的进化效果差不多。
    时间紧迫，语言设计得很烂，几乎没维护几个有用的性质，为了所谓的js编译级性能把进化效率全丢了。
    虽然可以处理数组，有分支和循环，甚至可以表达抽象函数。有自构进化的自由度（理论上可表达自修改程序），但实际上几乎仍是只能进化出简单的程序。因此不能算0.3。
    
</div>
</details>

<br>

<div>
    0.3级别：自构
    生命程序产生后代的基因并非固定的交叉和变异算子，而是由程序本身决定后代基因。<b>自构进化（Autoconstructive Evolution）</b>才能让智能体处处拥有编程级的自由度。
    <!-- 达到0.3级别的实现：<a href="0.3">世界运行0.3</a>，实现于？年？月。 -->
    <!-- 效果：生命在进化中自发学会了多智能体合作，形成了自组织的<b>集群智能</b>，例如自动进化出“蚁群”算法。 -->
</div>
<div>
    0.4级别：自创
    生命程序可以<b>自定义</b>世界的形状、交流<b>协议</b>等内容，不再局限于某个特定的世界结构（如2D网格、2D粒子、MC的方块+实体）。使得生命可以自己设计好的结构，降低为了迎合特定世界物理规则而进化出的不必要的算力使用（如神经网络，没必要模拟细胞细节，只需要抽象为权值和连接的模型即可）。
    <!-- 达到0.4级别的实现：<a href="0.4">世界运行0.4</a>，实现于？年？月。 -->
    <!-- 效果：生命只用很低的成本就实现了多层复杂系统涌现。 -->
</div>




<br>
<a href="theory/index.html">论广泛使用的神经网络</a>
<br>
<style>
    .INV{color: #0000000B;}
</style>
<div>
    <a class="INV" href="wasting-time/calculator.html">论计算器</a>
    <a class="INV" href="wasting-time/learn-programming-without-internet.html">在没有网的前提下学跨平台编程</a>
    <a class="INV" href="wasting-time/pressing-speed.html">按键速度测试</a> <a class="INV" href="wasting-time/typing-speed.html">打字速度测试</a>

</div>
</div>



</body></html>
<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>世界运行</title>
</head>

<style>
</style>
<body>
<h1>世界运行（人工生命系统模拟）</h1>
<br><br>
<h2>各等级各架构及核心思想</h2>
<div>
	<h3>0.2.1</h3><ul>
		<li><a href="treeWorld">满树架构</a>：实现于2025年9月。<br>
			树的一个节点就表示树的，保留父节点引用<br>
			所有树都是合法的程序，所有节点都是满的，只能交换相同类型的子树。
		</li>
		<li><a href="stringRewriting">字符串重写系统</a>：实现于2025年9月。<br>
			类似<a href="https://store.steampowered.com/app/1720850">《A=B》</a>的字符串重写系统，改进点为：靠转义实现规则自复制程序。<br>
		</li>
		<li><a href="0.2.1">栈类型区分的后缀表达式</a>：实现于2025年4月。<br>
			启发自<a href="https://faculty.hampshire.edu/lspector/push.html">Push语言</a>，改进点为：靠约束保证了程序可编译为js而非低效的解释。<br>
			（错误的创新）指令统一为int，任何int数组都带一个指针集实现数组树，虽然int数组既是程序也是数据，实现了“代码即数据”，但这导致设计异常复杂，极大增加维护成本，不如原版Push语言。<br>
			（弊大于利的创新）使用不可变数据结构，使数组复制为O(1)。但增加了设计复杂度，且导致更高频的数组修改性能降低，属于为了保证仅操作int数组类型及复用int数组的编译结果的妥协。
		</li>
	</ul>
	
	<h3>0.2.0</h3><ul>
		<li><a href="imageWorld">前缀表达式架构+图案渲染</a>：实现于2025年10月。<br>
			前缀表达式可以知道下一个未完成节点的类型需求，随机寻找类型符合的指令即可完成表达式的生成。<br>
			程序编译为js，在图案这种重复计算上相比解释执行性能提升巨大。
		</li>
		<li><a href="0.2">线性指令程序</a>：实现于2021年10月。<br>
			任何指令组合均为合法程序。类似于仅有指令的汇编。数值对应动作。
		</li>
	</ul>
	
	<h3>0.1.0</h3><ul>
		<li><a href="0.1">固定程序</a>：实现于2021年5月。<br>
			仅仅是个类似于<a href="https://www.baidu.com/s?wd=狼吃羊吃草模型"><del>狼吃</del>羊吃草模型</a>的东西。
		</li>
	</ul>
	
		
</div>

<br><br>
<h2>各等级简介</h2>
<div>
	<h3>0.1：世界运行</h3>
	<ul>
		<h3>0.1.0：</h3>
		<li>下限：世界中个体的程序会自动运行。只要规则恰当（如b3s23或boids或神经网络），就会涌现出因<b style="color: green;">适应程序规则</b>而产生的动态图案。</li>
		<li>上限：程序固定，每个单元的<b style="color: red;">自由度很低</b>，如只有几个向量，无法表达复杂的内部结构。这导致必须靠大量个体才可能实现通用计算，但由于个体过于简单，要实现精确计算就必须<b style="color: red;">大量冗余</b>，因此在冯诺依曼架构下效率极低。</li>
	</ul>
	<h3>0.2：生命进化</h3>
	<ul>
		<h3>0.2.0：</h3>
		<li>下限：遗传编程级，生命的基因可变，<b style="color: green;">可自由表达</b>图灵完备程序</li>
		<li>上限：基因程序<b style="color: red;">没有修改基因本身的自由度</b>，遗传操作<b style="color: red;">只能靠人设计</b>固定算子</li>
		<h3>0.2.1：</h3>
		<li>下限：在0.2.0的基础上加入基因底层操作的指令，可以实现Quine程序（自产生程序），<b style="color: green;">理论上可以实现任何基因遗传操作算子</b></li>
		<li>上限：虽然理论上可以对基因进行任何自操作，但与遗传操作完全固定的遗传编程相比<b style="color: red;">在效果上没有明显优势</b></li>
	</ul>
	<h3>0.3：未知，可能是是自构进化（Autoconstructive Evolution）或高级的集群涌现（生命体具有学习能力）</h3>
	<ul>

	</ul>
	<h3>0.4：未知，可能是元进化，生命可以自定义规则创造世界、自创语言和交流协议，不再局限于人设计的世界结构和程序形式</h3>
	<ul>
		
	</ul>
</div>
<br>


<details>
<summary style="list-style: none; color: #444;">　四年做不出0.3</summary>
<div style="color: #006600;white-space: pre-wrap;">
    我很希望我的每一个新版本，都能给我自己带来惊喜。我真的很不想水版本。
    做出0.1的惊喜在于自己第一次动手实现了可随时修改源代码的运行的世界。
    做出0.2的惊喜在于自己第一次动手实现了可随时修改源代码来影响生命进化进程的世界。
    由于我搜索“进化的进化”了解到了自构进化，我原定0.3目标就是实现自构进化。

    然而，实现0.2后，那段时间我发现了很多别人的人工生命项目，例如：
    <a href="https://alien-project.org/">Artificial Life Environment</a>，（靠<a href="https://alien-project.gitbook.io/docs/dive-a-little-deeper/cell-programming/self-replicating-machines">特别设计的GPU汇编语言</a>实现自构，同时靠GPU实现了单机百万生命的壮观景象）
    <a href="https://faculty.hampshire.edu/lspector/gecco2003-collective.html">SwarmEvolve</a>，（靠<a href="https://faculty.hampshire.edu/lspector/push.html">Push语言</a>实现自构）
    <a href="https://github.com/PaulTOliver/salis-v2">Salis</a>（靠类似Tierra的一维内存自修改代码实现自构）
    <a href="https://github.com/Reconcyl/myco">Myco</a>（靠类似Tierra的二维内存自修改代码实现自构）
    虽然发现了很多有意思的内容，但总体景象都大差不差：生命模式总是像一群微生物一样简单，偶尔随便进化几个基因。
    哪怕GPU千倍算力于CPU，达到百万生命了，也不足以自发进化出复杂的模式。因为一滴水的生命就远超这个数目，地球那么大都得进化几十亿年。

    0.2后，我直接就把0.3的目标定为“有学习能力的智能”，不管这个目标有多难，我都想在0.3一步登天。后来我才明白，“智能”这个目标是1.0级的。
    “人类科技发展越来越快，现实的生命也是自我进化，越到后期进化速度越快，通用AI出来后技术将直接爆炸”是对的，<b>但是</b>，前面这几十亿年的<b>前期</b>无论如何都是省略不掉的。

    哪怕明知算法优化到极致后个人电脑算力都能运行通用AI，哪怕通用AI每秒都能自我改进1%，但目前就是处于通用AI出现之前的阶段，电脑程序没法自我进化就是没法自我进化。
    哪怕明知通用学习能力的核心算法肯定能在10000字节内表示，哪怕自构能实现极强的自由度，哪怕知道肯定存在进化算法能做到每秒优化1个bit，几小时就能做出AGI。可是就是没人发现这个算法。

    3年了，我一直在想有什么取巧的方法，或者在1.0之前应该分为哪些阶段。于是便一直研究理论方面，研究了很久很久，3年了，理论还是没有找到。
    0.3的目标换了很多个了：“自我进化程序”、“找出能出现智能的模式”、“每秒能优化1个bit而不会陷入局部最优点的进化算法”、“让生命往最关乎智能和学习能力的方向进化”，总觉得每个都存在不需要以有AGI为前提的解决方法，但总是发现不了。最终把这些词都定性为“智能”的<b>等价</b>表达。天天换说法，就是不解决根本问题。

    为什么一直没进展呢？因为完美主义害人。因为“版本号不能水”，就不能随便写项目。“0.1世界运行，0.2生命进化”，按这个趋势0.3就应该是“智能爆炸”了。问题是这属于科技最前沿，那篇AGI的几万字的论文还没写出来，写AGI代码，每想写出一个正确的字符都举步维艰。

    （2025年1月）
    3年了，读个大学，大一做出的0.2，到大四快毕业了，0.3还迟迟做不出来，像话吗？
    0.2到0.3这版本跨度无论如何都不应该这么久。哪怕从0.1的不进化到0.2的进化属于质的飞跃，也只花了很短时间。如果非要把0.3定义为“出现智能”这个级别的目标，版本永远没法迭代。
    无法迭代版本，便没有目标，没有目标便没有写项目的动力。所以中间这3年我没有写出有质的飞跃的项目，哪怕是“小型”的质的飞跃。

    最终，我把毕业论文和0.3挂钩了，这次无论如何我都要写出一个东西来。
    0.3的目标就定为“自构进化”吧，反正随便写写都能实现自复制机器，就算随便从我的理论研究中拿出五六个自创点子都能造出个有意思的东西，保证能毕业。

    （2025年8月）
    但最终，毕业设计的结果只能算是0.2.1，因为和0.2的进化效果差不多。
    时间紧迫，语言设计得很烂，几乎没维护几个有用的性质，为了所谓的js编译级性能把进化效率全丢了。
    虽然可以处理数组，有分支和循环，甚至可以表达抽象函数。有自构进化的自由度（理论上可表达自修改程序），但实际上几乎仍是只能进化出简单的程序。因此不能算0.3。
    
</div>
</details>

<br>
<br>
<a href="theory/index.html">论广泛使用的神经网络</a>
<br>
<style>
    .INV{color: #0000000B;}
</style>
<div>
    <a class="INV" href="wasting-time/calculator.html">论计算器</a>
    <a class="INV" href="wasting-time/learn-programming-without-internet.html">在没有网的前提下学跨平台编程</a>
    <a class="INV" href="wasting-time/pressing-speed.html">按键速度测试</a> <a class="INV" href="wasting-time/typing-speed.html">打字速度测试</a>

</div>
</div>



</body></html>